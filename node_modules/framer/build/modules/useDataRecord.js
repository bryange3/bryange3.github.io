import { useMemo } from "react";
/**
 * Given a collection (array of objects), a path template (e.g., `/blog/:slug`)
 * and a concrete path (e.g., `/blog/hello-world`), returns an object with data
 * for the record in the collection that has a matching property (e.g.,
 * `record.slug === "hello-world"`). Returns `null` if no record was found.
 * @internal
 */
export function useDataRecord(collection, pathTemplate, path) {
    const pathParser = useMemo(() => getPathParser(pathTemplate), [pathTemplate]);
    const variables = useMemo(() => pathParser(path), [pathParser, path]);
    return useMemo(() => {
        if (!Array.isArray(collection)) {
            return null;
        }
        const pageRecord = collection.find(record => {
            return Object.entries(variables).every(([key, value]) => record[key] !== undefined && String(record[key]) === value);
        });
        return pageRecord ?? null;
    }, [collection, variables]);
}
const rePathVariables = /:([a-zA-Z][a-zA-Z0-9_]*)/g;
/**
 * Turns a path pattern like `/blog/:slug` into a function that can receive an
 * actual path like `/blog/hello-world` and return an object with the matched
 * variables (`{ slug: "hello-world" }`).
 */
function getPathParser(path) {
    const names = [];
    const re = new RegExp(rePathVariables);
    let pathVariableMatch;
    while ((pathVariableMatch = re.exec(path)) !== null) {
        names.push(pathVariableMatch[1]);
    }
    const safePath = escapeStringRegexp(path);
    const pathMatcher = new RegExp(`^${safePath.replace(rePathVariables, "([^/]+)")}$`);
    return (input) => {
        const result = {};
        const match = input.match(pathMatcher);
        if (match) {
            for (let i = 1; i < match.length; i++) {
                result[names[i - 1]] = decodeURIComponent(match[i]);
            }
        }
        return result;
    };
}
function escapeStringRegexp(string) {
    return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
//# sourceMappingURL=useDataRecord.js.map