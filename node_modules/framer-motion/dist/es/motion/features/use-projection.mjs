import { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';
import { isRefObject } from '../../utils/is-ref-object.mjs';

function useProjection(projectionId, _a, visualElement, initialPromotionConfig) {
    var _b;
    var layoutId = _a.layoutId, layout = _a.layout, drag = _a.drag, dragConstraints = _a.dragConstraints, shouldMeasureScroll = _a.shouldMeasureScroll;
    if (!visualElement || (visualElement === null || visualElement === void 0 ? void 0 : visualElement.projection))
        return;
    visualElement.projection = new HTMLProjectionNode(projectionId, visualElement.getLatestValues(), (_b = visualElement.parent) === null || _b === void 0 ? void 0 : _b.projection);
    visualElement.projection.setOptions({
        layoutId: layoutId,
        layout: layout,
        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),
        visualElement: visualElement,
        scheduleRender: function () { return visualElement.scheduleRender(); },
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout === "string" ? layout : "both",
        initialPromotionConfig: initialPromotionConfig,
        shouldMeasureScroll: shouldMeasureScroll,
    });
}

export { useProjection };
